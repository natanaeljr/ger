use crate::accounts::{AccountInfo, AccountInput, GpgKeyInfo};
use crate::details::Timestamp;
use serde::{Serialize, Serializer};
use serde_derive::{Deserialize, Serialize};
use std::collections::{BTreeMap, HashMap};
use std::fmt::{Display, Error, Formatter};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// JSON Entities
////////////////////////////////////////////////////////////////////////////////////////////////////

/// The AbandonInput entity contains information for abandoning a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct AbandonInput {
    /// Message to be added as review comment to the change when abandoning the change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Notify handling that defines to whom email notifications should be sent
    /// after the change is abandoned.
    /// If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
}

/// The ActionInfo entity describes a REST API call the client can make to manipulate a resource.
/// These are frequently implemented by plugins and may be discovered at runtime.
#[derive(Debug, Serialize, Deserialize)]
pub struct ActionInfo {
    /// HTTP method to use with the action.
    /// Most actions use POST, PUT or DELETE to cause state changes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<HttpMethod>,
    /// Short title to display to a user describing the action. In the Gerrit web interface the
    /// label is used as the text on the button presented in the UI.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// Longer text to display describing the action. In a web UI this should be the title attribute
    /// of the element, displaying when the user hovers the mouse.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// If true the action is permitted at this time and the caller is likely allowed to execute it.
    /// This may change if state is updated at the server or permissions are modified.
    #[serde(default)]
    pub enabled: bool,
}

/// The AddReviewerResult entity describes the result of adding a reviewer to a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddReviewerResult {
    /// Value of the reviewer field from ReviewerInput set while adding the reviewer.
    pub input: String,
    /// The newly added reviewers as a list of ReviewerInfo entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewers: Option<Vec<ReviewerInfo>>,
    /// The newly CCed accounts as a list of ReviewerInfo entities. This field will only appear if
    /// the requested state for the reviewer was CC and NoteDb is enabled on the server.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ccs: Option<Vec<ReviewerInfo>>,
    /// Error message explaining why the reviewer could not be added.
    /// If a group was specified in the input and an error is returned, it means that none of the
    /// members were added as reviewer.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    /// Whether adding the reviewer requires confirmation.
    #[serde(default)]
    pub confirm: bool,
}

/// The ApprovalInfo entity contains information about an approval from a user for a label on a change.
/// ApprovalInfo has the same fields as AccountInfo. In addition to the following fields:
#[derive(Debug, Serialize, Deserialize)]
pub struct ApprovalInfo {
    /// The account information entity.
    #[serde(flatten)]
    pub account: AccountInfo,
    /// The vote that the user has given for the label. If present and zero, the user is permitted
    /// to vote on the label. If absent, the user is not permitted to vote on that label.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<i32>,
    /// The VotingRangeInfo the user is authorized to vote on that label. If present, the user is
    /// permitted to vote on the label regarding the range values. If absent, the user is not
    /// permitted to vote on that label.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub permitted_voting_range: Option<VotingRangeInfo>,
    /// The time and date describing when the approval was made.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub date: Option<Timestamp>,
    /// Value of the tag field from ReviewInput set while posting the review. Votes/comments that
    /// contain tag with 'autogenerated:' prefix can be filtered out in the web UI. NOTE: To apply
    /// different tags on different votes/comments multiple invocations of the REST call are required.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
    /// If true, this vote was made after the change was submitted.
    #[serde(default)]
    pub post_submit: bool,
}

/// The AssigneeInput entity contains the identity of the user to be set as assignee.
#[derive(Debug, Serialize, Deserialize)]
pub struct AssigneeInput {
    /// The ID of one account that should be added as assignee.
    pub assignee: String,
}

/// The BlameInfo entity stores the commit metadata with the row coordinates where it applies.
#[derive(Debug, Serialize, Deserialize)]
pub struct BlameInfo {
    /// The author of the commit.
    pub author: String,
    /// The id of the commit.
    pub id: String,
    /// Commit time.
    pub time: String,
    /// The commit message.
    pub commit_msg: String,
    /// The blame row coordinates as RangeInfo entities.
    pub ranges: Vec<RangeInfo>,
}

/// The ChangeEditInput entity contains information for restoring a path within change edit.
#[derive(Debug, Serialize, Deserialize)]
pub struct ChangeEditInput {
    /// Path to file to restore.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub restore_path: Option<String>,
    /// Old path to file to rename.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_path: Option<String>,
    /// New path to file to rename.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_path: Option<String>,
}

/// The ChangeEditMessageInput entity contains information for changing the commit message
/// within a change edit.
#[derive(Debug, Serialize, Deserialize)]
pub struct ChangeEditMessageInput {
    /// New commit message.
    pub message: String,
}

/// The ChangeInfo entity contains information about a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct ChangeInfo {
    /// The ID of the change in the format "'<project>~<branch>~<Change-Id>'",
    /// where 'project', 'branch' and 'Change-Id' are URL encoded.
    /// For 'branch' the refs/heads/ prefix is omitted.
    pub id: String,
    /// The name of the project.
    pub project: String,
    /// The name of the target branch. The refs/heads/ prefix is omitted.
    pub branch: String,
    /// The topic to which this change belongs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
    /// The assignee of the change as an AccountInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignee: Option<AccountInfo>,
    /// List of hashtags that are set on the change (only populated when NoteDb is enabled).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hashtags: Option<Vec<String>>,
    /// The Change-Id of the change.
    pub change_id: String,
    /// The subject of the change (header line of the commit message).
    pub subject: String,
    /// The status of the change.
    pub status: ChangeStatus,
    /// The timestamp of when the change was created.
    pub created: Timestamp,
    /// The timestamp of when the change was last updated.
    pub updated: Timestamp,
    /// The timestamp of when the change was submitted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub submitted: Option<Timestamp>,
    /// The user who submitted the change, as an AccountInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub submitter: Option<AccountInfo>,
    /// Whether the calling user has starred this change with the default label.
    #[serde(default)]
    pub starred: bool,
    /// A list of star labels that are applied by the calling user to this change.
    /// The labels are lexicographically sorted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stars: Option<Vec<String>>,
    /// Whether the change was reviewed by the calling user. Only set if reviewed is requested.
    #[serde(default)]
    pub reviewed: bool,
    /// The submit type of the change. Not set for merged changes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub submit_type: Option<SubmitType>,
    /// Whether the change is mergeable. Not set for merged changes, if the change has not yet
    /// been tested, or if the skip_mergeable option is set or when
    /// change.api.excludeMergeableInChangeInfo is set.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mergeable: Option<bool>,
    /// Whether the change has been approved by the project submit rules. Only set if requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub submittable: Option<bool>,
    /// Number of inserted lines.
    pub insertions: u32,
    /// Number of deleted lines.
    pub deletions: u32,
    /// Total number of inline comments across all patch sets.
    /// Not set if the current change index doesn’t have the data.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_comment_count: Option<u32>,
    /// Number of unresolved inline comment threads across all patch sets.
    /// Not set if the current change index doesn’t have the data.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unresolved_comment_count: Option<u32>,
    /// The legacy numeric ID of the change.
    #[serde(rename = "_number")]
    pub number: u32,
    /// The owner of the change as an AccountInfo entity.
    pub owner: AccountInfo,
    /// Actions the caller might be able to perform on this revision.
    /// The information is a map of view name to ActionInfo entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<HashMap<String, ActionInfo>>,
    /// List of the requirements to be met before this change can be submitted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirements: Option<Vec<Requirement>>,
    /// The labels of the change as a map that maps the label names to LabelInfo entries.
    /// Only set if labels or detailed labels are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, LabelInfo>>,
    /// A map of the permitted labels that maps a label name to the list of values that are allowed
    /// for that label. Only set if detailed labels are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub permitted_labels: Option<HashMap<String, Vec<String>>>,
    /// The reviewers that can be removed by the calling user as a list of AccountInfo entities.
    /// Only set if detailed labels are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub removable_reviewers: Option<Vec<AccountInfo>>,
    /// The reviewers as a map that maps a reviewer state to a list of AccountInfo entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewers: Option<HashMap<ReviewerState, Vec<AccountInfo>>>,
    /// Updates to reviewers that have been made while the change was in the WIP state.
    /// Only present on WIP changes and only if there are pending reviewer updates to report.
    /// These are reviewers who have not yet been notified about being added to or removed from the change.
    /// Only set if detailed labels are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pending_reviewers: Option<HashMap<ReviewerState, Vec<AccountInfo>>>,
    /// Updates to reviewers set for the change as ReviewerUpdateInfo entities.
    /// Only set if reviewer updates are requested and if NoteDb is enabled.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewer_updates: Option<Vec<ReviewerUpdateInfo>>,
    /// Messages associated with the change as a list of ChangeMessageInfo entities.
    /// Only set if messages are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub messages: Option<Vec<ChangeMessageInfo>>,
    /// The commit ID of the current patch set of this change.
    /// Only set if the current revision is requested or if all revisions are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_revision: Option<String>,
    /// All patch sets of this change as a map that maps the commit ID of the patch set
    /// to a RevisionInfo entity. Only set if the current revision is requested (in which case
    /// it will only contain a key for the current revision) or if all revisions are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub revisions: Option<HashMap<String, RevisionInfo>>,
    /// A list of TrackingIdInfo entities describing references to external tracking systems.
    /// Only set if tracking ids are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tracking_ids: Option<Vec<TrackingIdInfo>>,
    /// Whether the query would deliver more results if not limited.
    /// Only set on the last change that is returned.
    #[serde(default, rename = "_more_changes")]
    pub more_changes: bool,
    /// A list of ProblemInfo entities describing potential problems with this change.
    /// Only set if CHECK is set.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub problems: Option<Vec<ProblemInfo>>,
    /// When present, change is marked as private.
    #[serde(default)]
    pub is_private: bool,
    /// When present, change is marked as Work In Progress.
    #[serde(default)]
    pub work_in_progress: bool,
    /// When present, change has been marked Ready at some point in time.
    #[serde(default)]
    pub has_review_started: bool,
    /// The numeric Change-Id of the change that this change reverts.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub revert_of: Option<u32>,
    /// ID of the submission of this change. Only set if the status is MERGED.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub submission_id: Option<String>,
}

/// The ChangeInput entity contains information about creating a new change.
#[derive(Debug, Serialize, Deserialize)]
pub struct ChangeInput {
    /// The name of the project.
    pub project: String,
    /// The name of the target branch.
    /// The refs/heads/ prefix is omitted.
    pub branch: String,
    /// The commit message of the change. Comment lines (beginning with #) will be removed.
    pub subject: String,
    /// The topic to which this change belongs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
    /// The status of the change (only NEW accepted here).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ChangeStatus>,
    /// Whether the new change should be marked as private.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_private: Option<bool>,
    /// Whether the new change should be set to work in progress.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub work_in_progress: Option<bool>,
    /// A {change-id} that identifies the base change for a create change operation.
    /// Mutually exclusive with base_commit.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_change: Option<String>,
    /// A 40-digit hex SHA-1 of the commit which will be the parent commit of the newly
    /// created change. If set, it must be a merged commit on the destination branch.
    /// Mutually exclusive with base_change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_commit: Option<String>,
    /// Allow creating a new branch when set to true.
    /// Using this option is only possible for non-merge commits (if the merge field is not set).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_branch: Option<bool>,
    /// The detail of a merge commit as a MergeInput entity.
    /// If set, the target branch (see branch field) must exist (it is not possible to create it
    /// automatically by setting the new_branch field to true.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub merge: Option<MergeInput>,
    /// An AccountInput entity that will set the author of the commit to create.
    /// The author must be specified as name/email combination.
    /// The caller needs "Forge Author" permission when using this field.
    /// This field does not affect the owner of the change, which will continue to use the identity
    /// of the caller.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<AccountInput>,
    /// Notify handling that defines to whom email notifications should be sent after the change is
    /// created. If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
}

/// Change kind.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ChangeKind {
    Rework,
    TrivialRebase,
    MergeFirstParentUpdate,
    NoCodeChange,
    NoChange,
}

/// The ChangeMessageInfo entity contains information about a message attached to a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct ChangeMessageInfo {
    /// The ID of the message.
    pub id: String,
    /// Author of the message as an AccountInfo entity.
    /// Unset if written by the Gerrit system.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<AccountInfo>,
    /// Real author of the message as an AccountInfo entity.
    /// Set if the message was posted on behalf of another user.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub read_author: Option<AccountInfo>,
    /// The timestamp this message was posted.
    pub date: Timestamp,
    /// The text left by the user.
    pub message: String,
    /// Value of the tag field from ReviewInput set while posting the review.
    /// Votes/comments that contain tag with 'autogenerated:' prefix can be filtered out in the web UI.
    /// NOTE: To apply different tags on different votes/comments multiple invocations of the REST call are required.
    pub tag: String,
    /// Which patchset (if any) generated this message.
    #[serde(rename = "_revision_number", skip_serializing_if = "Option::is_none")]
    pub revision_number: Option<u32>,
}

/// The status of a change.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ChangeStatus {
    New,
    Merged,
    Abandoned,
    Draft,
}

impl std::fmt::Display for ChangeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.write_str(match self {
            ChangeStatus::New => "NEW",
            ChangeStatus::Merged => "MERGED",
            ChangeStatus::Abandoned => "ABANDONED",
            ChangeStatus::Draft => "DRAFT",
        })
    }
}

/// The type of change.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ChangeType {
    Added,
    Modified,
    Deleted,
    Renamed,
    Copied,
    Rewrite,
}

/// The CherryPickInput entity contains information for cherry-picking a change to a new branch.
#[derive(Debug, Serialize, Deserialize)]
pub struct CherryPickInput {
    /// Commit message for the cherry-pick change. If not set, the commit message of the
    /// cherry-picked commit is used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Destination branch.
    pub destination: String,
    /// 40-hex digit SHA-1 of the commit which will be the parent commit of the newly created change.
    /// If set, it must be a merged commit or a change revision on the destination branch.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base: Option<String>,
    /// Number of the parent relative to which the cherry-pick should be considered.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<u32>,
    /// Notify handling that defines to whom email notifications should be sent after the change is
    /// created. If not set, the default is NONE.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
    /// If true, carries reviewers and ccs over from original change to newly created one.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keep_reviewers: Option<bool>,
    /// If true, the cherry-pick uses content merge and succeeds also if there are conflicts.
    /// If there are conflicts the file contents of the created change contain git conflict markers
    /// to indicate the conflicts. Callers can find out if there were conflicts by checking the
    /// contains_git_conflicts field in the ChangeInfo. If there are conflicts the cherry-pick
    /// change is marked as work-in-progress.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow_conflicts: Option<bool>,
}

/// The CommentInfo entity contains information about an inline comment.
#[derive(Debug, Serialize, Deserialize)]
pub struct CommentInfo {
    /// The patch set number for the comment; only set in contexts where
    /// comments may be returned for multiple patch sets.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub patch_set: Option<u32>,
    /// The URL encoded UUID of the comment.
    pub id: String,
    /// The path of the file for which the inline comment was done.
    /// Not set if returned in a map where the key is the file path.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The side on which the comment was added.
    /// Allowed values are REVISION and PARENT. If not set, the default is REVISION.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub side: Option<CommentSide>,
    /// The 1-based parent number. Used only for merge commits when side == PARENT.
    /// When not set the comment is for the auto-merge tree.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// The number of the line for which the comment was done.
    /// If range is set, this equals the end line of the range.
    /// If neither line nor range is set, it’s a file comment.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line: Option<u32>,
    /// The range of the comment as a CommentRange entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range: Option<CommentRange>,
    /// The URL encoded UUID of the comment to which this comment is a reply.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub in_reply_to: Option<String>,
    /// The comment message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// The timestamp of when this comment was written.
    pub updated: Timestamp,
    /// The author of the message as an AccountInfo entity.
    /// Unset for draft comments, assumed to be the calling user.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<AccountInfo>,
    /// Value of the tag field from ReviewInput set while posting the review.
    /// NOTE: To apply different tags on different votes/comments multiple invocations of the REST call are required.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
    /// Whether or not the comment must be addressed by the user.
    /// The state of resolution of a comment thread is stored in the last comment in that thread chronologically.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unresolved: Option<bool>,
}

/// The CommentInput entity contains information for creating an inline comment.
#[derive(Debug, Serialize, Deserialize)]
pub struct CommentInput {
    /// The URL encoded UUID of the comment if an existing draft comment should be updated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The path of the file for which the inline comment should be added.
    /// Doesn’t need to be set if contained in a map where the key is the file path.    
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The side on which the comment was added.
    /// Allowed values are REVISION and PARENT. If not set, the default is REVISION.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub side: Option<CommentSide>,
    /// The number of the line for which the comment should be added.
    /// 0 if it is a file comment.
    /// If neither line nor range is set, a file comment is added.
    /// If range is set, this value is ignored in favor of the end_line of the range.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line: Option<u32>,
    /// The range of the comment as a CommentRange entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range: Option<CommentRange>,
    /// The URL encoded UUID of the comment to which this comment is a reply.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub in_reply_to: Option<String>,
    /// The timestamp of when this comment was written.
    /// Accepted but ignored.
    pub updated: Timestamp,
    /// The comment message.
    /// If not set and an existing draft comment is updated, the existing draft comment is deleted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Value of the tag field. Only allowed on draft comment inputs;
    /// for published comments, use the tag field in ReviewInput.
    /// Votes/comments that contain tag with 'autogenerated:' prefix can be filtered out in the web UI.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
    /// Whether or not the comment must be addressed by the user.
    /// This value will default to false if the comment is an orphan, or the value of the
    /// in_reply_to comment if it is supplied.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unresolved: Option<bool>,
}

/// The CommentRange entity describes the range of an inline comment.
/// The comment range is a range from the start position, specified by start_line and
/// start_character, to the end position, specified by end_line and end_character.
/// The start position is inclusive and the end position is exclusive.
/// So, a range over part of a line will have start_line equal to end_line;
/// however a range with end_line set to 5 and end_character equal to 0 will not include any
/// characters on line 5,
#[derive(Debug, Serialize, Deserialize)]
pub struct CommentRange {
    /// The start line number of the range. (1-based)
    pub start_line: u32,
    /// The character position in the start line. (0-based)
    pub start_character: u32,
    /// The end line number of the range. (1-based)
    pub end_line: u32,
    /// The character position in the end line. (0-based)
    pub end_character: u32,
}

/// The CommitInfo entity contains information about a commit.
#[derive(Debug, Serialize, Deserialize)]
pub struct CommitInfo {
    /// The commit ID. Not set if included in a RevisionInfo entity that is contained in a map
    /// which has the commit ID as key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub commit: Option<String>,
    /// The parent commits of this commit as a list of CommitInfo entities.
    /// In each parent, only the commit and subject fields are populated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parents: Option<Vec<CommitInfo>>,
    /// The author of the commit as a GitPersonInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<GitPersonInfo>,
    /// The committer of the commit as a GitPersonInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub committer: Option<GitPersonInfo>,
    /// The subject of the commit (header line of the commit message).
    pub subject: String,
    /// The commit message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Links to the commit in external sites as a list of WebLinkInfo entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub web_links: Option<WebLinkInfo>,
}

/// The CommitMessageInput entity contains information for changing the commit message of a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct CommitMessageInput {
    pub message: String,
    /// Notify handling that defines to whom email notifications should be sent after
    /// the commit message was updated.
    /// If not set, the default is OWNER for WIP changes and ALL otherwise.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
}

/// The side on which the comment was added.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum CommentSide {
    Revision,
    Parent,
}

/// The DeleteChangeMessageInput entity contains the options for deleting a change message.
#[derive(Debug, Serialize, Deserialize)]
pub struct DeleteChangeMessageInput {
    /// The reason why the change message should be deleted.
    /// If set, the change message will be replaced with:
    /// "Change message removed by: name\nReason: reason`", or just "Change message removed by: `name." if not set.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// The DeleteCommentInput entity contains the option for deleting a comment.
#[derive(Debug, Serialize, Deserialize)]
pub struct DeleteCommentInput {
    /// The reason why the comment should be deleted.
    /// If set, the comment’s message will be replaced with:
    /// "Comment removed by: name; Reason: reason`", or just "Comment removed by: `name." if not set.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// The DeleteReviewerInput entity contains options for the deletion of a reviewer.
#[derive(Debug, Serialize, Deserialize)]
pub struct DeleteReviewerInput {
    /// Notify handling that defines to whom email notifications should be sent
    /// after the reviewer is deleted.
    /// If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
}

/// The DeleteVoteInput entity contains options for the deletion of a vote.
#[derive(Debug, Serialize, Deserialize)]
pub struct DeleteVoteInput {
    /// The label for which the vote should be deleted.
    /// If set, must match the label in the URL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// Notify handling that defines to whom email notifications should be sent after
    /// the vote is deleted.
    /// If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
}

/// The DescriptionInput entity contains information for setting a description.
#[derive(Debug, Serialize, Deserialize)]
pub struct DescriptionInput {
    /// The description text.
    pub description: String,
}

/// The DiffContent entity contains information about the content differences in a file.
#[derive(Debug, Serialize, Deserialize)]
pub struct DiffContent {
    /// Content only in the file on side A (deleted in B).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub a: Option<String>,
    /// Content only in the file on side B (added in B).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub b: Option<String>,
    /// Content in the file on both sides (unchanged).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ab: Option<String>,
    /// Text sections deleted from side A as a DiffIntralineInfo entity.
    /// Only present when the intraline parameter is set and the DiffContent is a replace,
    /// i.e. both a and b are present
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edit_a: Option<String>,
    /// Text sections inserted in side B as a DiffIntralineInfo entity.
    /// Only present when the intraline parameter is set and the DiffContent is a replace,
    /// i.e. both a and b are present
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edit_b: Option<String>,
    /// Indicates whether this entry was introduced by a rebase.
    #[serde(default)]
    pub due_to_rebase: bool,
    /// Count of lines skipped on both sides when the file is too large to include all common lines.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub skip: Option<i32>,
    /// Set to true if the region is common according to the requested ignore-whitespace parameter,
    /// but a and b contain differing amounts of whitespace. When present and true a and b are used instead of ab.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub common: Option<bool>,
}

/// The DiffFileMetaInfo entity contains meta information about a file diff.
#[derive(Debug, Serialize, Deserialize)]
pub struct DiffFileMetaInfo {
    /// The name of the file.
    pub name: String,
    /// The content type of the file.
    pub content_type: String,
    /// The total number of lines in the file.
    pub lines: u32,
    /// Links to the file in external sites as a list of WebLinkInfo entries.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub web_links: Option<Vec<WebLinkInfo>>,
}

/// The DiffInfo entity contains information about the diff of a file in a revision.
/// If the weblinks-only parameter is specified, only the web_links field is set.
#[derive(Debug, Serialize, Deserialize)]
pub struct DiffInfo {
    /// Meta information about the file on side A as a DiffFileMetaInfo entity.
    /// Not present when the file is added.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub meta_a: Option<DiffFileMetaInfo>,
    /// Meta information about the file on side B as a DiffFileMetaInfo entity.
    /// Not present when the file is deleted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub meta_b: Option<DiffFileMetaInfo>,
    /// The type of change
    pub change_type: ChangeType,
    /// The Intraline status.
    /// Only set when the intraline parameter was specified in the request.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intraline_status: Option<IntralineStatus>,
    /// A list of strings representing the patch set diff header.
    pub diff_header: Vec<String>,
    /// The content differences in the file as a list of DiffContent entities.
    pub content: Vec<DiffContent>,
    /// Links to the file diff in external sites as a list of DiffWebLinkInfo entries.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub web_links: Option<DiffWebLinkInfo>,
    /// Whether the file is binary.
    #[serde(default)]
    pub binary: bool,
}

/// The DiffIntralineInfo entity contains information about intraline edits in a file.
///
/// The information consists of a list of <skip length, edit length> pairs, where the skip length is
/// the number of characters between the end of the previous edit and the start of this edit, and
/// the edit length is the number of edited characters following the skip.
/// The start of the edits is from the beginning of the related diff content lines.
/// If the list is empty, the entire DiffContent should be considered as unedited.
///
/// Note that the implied newline character at the end of each line is included in the
/// length calculation,and thus it is possible for the edits to span newlines.
#[derive(Debug, Serialize, Deserialize)]
pub struct DiffIntralineInfo {
    #[serde(flatten)]
    pub values: Vec<String>,
}

/// The DiffWebLinkInfo entity describes a link on a diff screen to an external site.
#[derive(Debug, Serialize, Deserialize)]
pub struct DiffWebLinkInfo {
    /// The link name.
    pub name: String,
    /// The link URL.
    pub url: String,
    /// URL to the icon of the link.
    pub image_url: String,
    /// Whether the web link should be shown on the side-by-side diff screen.
    pub show_on_side_by_side_diff_view: bool,
    /// Whether the web link should be shown on the unified diff screen.
    pub show_on_unified_diff_view: bool,
}

/// Draft handling.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum DraftHandling {
    Publish,
    PublishAllRevisions,
    Keep,
}

/// The EditFileInfo entity contains additional information of a file within a change edit.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditFileInfo {
    /// Links to the diff info in external sites as a list of WebLinkInfo entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wbe_links: Option<Vec<WebLinkInfo>>,
}

/// The EditInfo entity contains information about a change edit.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInfo {
    /// The commit of change edit as CommitInfo entity.
    pub commit: CommitInfo,
    /// The patch set number of the patch set the change edit is based on.
    pub base_patch_set_number: u32,
    /// The revision of the patch set the change edit is based on.
    pub base_revision: u32,
    /// The ref of the change edit.
    #[serde(rename = "ref")]
    pub refspec: String,
    /// Information about how to fetch this patch set.
    /// The fetch information is provided as a map that maps the protocol name (“git”, “http”, “ssh”)
    /// to FetchInfo entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fetch: Option<BTreeMap<String, FetchInfo>>,
    /// The files of the change edit as a map that maps the file names to FileInfo entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, FileInfo>>,
}

/// The FetchInfo entity contains information about how to fetch a patch set via a certain protocol.
#[derive(Debug, Serialize, Deserialize)]
pub struct FetchInfo {
    pub url: String,
    /// The ref of the patch set.
    #[serde(rename = "ref")]
    pub refspec: String,
    /// The download commands for this patch set as a map that maps the command names to the commands.
    /// Only set if download commands are requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub commands: Option<HashMap<String, String>>,
}

/// The FileInfo entity contains information about a file in a patch set.
#[derive(Debug, Serialize, Deserialize)]
pub struct FileInfo {
    /// The status of the file
    #[serde(default)]
    pub status: FileStatus,
    /// Whether the file is binary.
    #[serde(default)]
    pub binary: bool,
    /// The old file path.
    /// Only set if the file was renamed or copied.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_path: Option<String>,
    /// Number of inserted lines.
    /// Not set for binary files or if no lines were inserted.
    /// An empty last line is not included in the count and hence this number can differ by one
    /// from details provided in <<#diff-info,DiffInfo>>.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lines_inserted: Option<u32>,
    /// Number of deleted lines.
    /// Not set for binary files or if no lines were deleted.
    /// An empty last line is not included in the count and hence this number can differ by one
    /// from details provided in <<#diff-info,DiffInfo>>.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lines_deleted: Option<u32>,
    /// Number of bytes by which the file size increased/decreased.
    pub size_delta: i32,
    /// File size in bytes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<u32>,
}

/// File status.
#[derive(Debug, Serialize, Deserialize)]
pub enum FileStatus {
    #[serde(rename = "M")]
    Modified,
    #[serde(rename = "A")]
    Added,
    #[serde(rename = "D")]
    Deleted,
    #[serde(rename = "R")]
    Renamed,
    #[serde(rename = "C")]
    Copied,
    #[serde(rename = "W")]
    Rewritten,
}

impl Default for FileStatus {
    fn default() -> Self {
        FileStatus::Modified
    }
}

impl FileStatus {
    pub fn initial(&self) -> char {
        match self {
            FileStatus::Modified => 'M',
            FileStatus::Added => 'A',
            FileStatus::Deleted => 'D',
            FileStatus::Renamed => 'R',
            FileStatus::Copied => 'C',
            FileStatus::Rewritten => 'W',
        }
    }
}

/// The FixInput entity contains options for fixing commits using the fix change endpoint.
#[derive(Debug, Serialize, Deserialize)]
pub struct FixInput {
    /// If true, delete patch sets from the database if they refer to missing commit options.
    pub delete_patch_set_if_commit_missing: bool,
    /// If set, check that the change is merged into the destination branch as this exact SHA-1.
    /// If not, insert a new patch set referring to this commit.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expect_merged_as: Option<String>,
}

/// The FixSuggestionInfo entity represents a suggested fix.
#[derive(Debug, Serialize, Deserialize)]
pub struct FixSuggestionInfo {
    /// The UUID of the suggested fix.
    /// It will be generated automatically and hence will be ignored if it’s set for input objects.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fix_id: Option<String>,
    /// A description of the suggested fix.
    pub description: String,
    /// A list of FixReplacementInfo entities indicating how the content of one or several files
    /// should be modified. Within a file, they should refer to non-overlapping regions.
    pub replacements: Vec<FixReplacementInfo>,
}

/// The FixReplacementInfo entity describes how the content of a file should be replaced by another content.
#[derive(Debug, Serialize, Deserialize)]
pub struct FixReplacementInfo {
    /// The path of the file which should be modified. Any file in the repository may be modified.
    pub path: String,
    /// A CommentRange indicating which content of the file should be replaced.
    /// Lines in the file are assumed to be separated by the line feed character,
    /// the carriage return character, the carriage return followed by the line feed character,
    /// or one of the other Unicode linebreak sequences supported by Java.
    pub range: CommentRange,
    /// The content which should be used instead of the current one.
    pub replacement: String,
}

/// The GitPersonInfo entity contains information about the author/committer of a commit.
#[derive(Debug, Serialize, Deserialize)]
pub struct GitPersonInfo {
    /// The name of the author/committer.
    pub name: String,
    /// The email address of the author/committer.
    pub email: String,
    /// The timestamp of when this identity was constructed.
    pub date: Timestamp,
    /// The timezone offset from UTC of when this identity was constructed.
    pub tz: i32,
}

/// The GroupBaseInfo entity contains base information about the group.
#[derive(Debug, Serialize, Deserialize)]
pub struct GroupBaseInfo {
    /// The UUID of the group.
    pub id: String,
    /// The name of the group.
    pub name: String,
}

/// The HashtagsInput entity contains information about hashtags to add to, and/or remove from, a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct HashtagsInput {
    /// The list of hashtags to be added to the change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// The list of hashtags to be removed from the change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
}

/// Common HTTP methods to cause state changes.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum HttpMethod {
    Post,
    Put,
    Delete,
}

/// The IncludedInInfo entity contains information about the branches a change was merged into and tags it was tagged with.
#[derive(Debug, Serialize, Deserialize)]
pub struct IncludedInInfo {
    /// The list of branches this change was merged into. Each branch is listed without the 'refs/head/' prefix.
    pub branches: Vec<String>,
    /// The list of tags this change was tagged with. Each tag is listed without the 'refs/tags/' prefix.
    pub tags: Vec<String>,
    /// A map that maps a name to a list of external systems that include this change,
    /// e.g. a list of servers on which this change is deployed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub external: Option<HashMap<String, String>>,
}

/// The Intraline status.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum IntralineStatus {
    Ok,
    Error,
    Timeout,
}

/// The LabelInfo entity contains information about a label on a change, always corresponding to the
/// current patch set.
/// There are two options that control the contents of LabelInfo: LABELS and DETAILED_LABELS.
///  - For a quick summary of the state of labels, use LABELS.
///  - For detailed information about labels, including exact numeric votes for all users and the
///    allowed range of votes for the current user, use DETAILED_LABELS.
#[derive(Debug, Serialize, Deserialize)]
pub struct LabelInfo {
    /// Whether the label is optional. Optional means the label may be set,
    /// but it’s neither necessary for submission nor does it block submission if set.
    #[serde(default)]
    pub optional: bool,
    /// One user who approved this label on the change (voted the maximum value) as an AccountInfo.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub approved: Option<AccountInfo>,
    /// One user who rejected this label on the change (voted the minimum value) as an AccountInfo.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rejected: Option<AccountInfo>,
    /// One user who recommended this label on the change (voted positively,
    /// but not the maximum value) as an AccountInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommended: Option<AccountInfo>,
    /// One user who disliked this label on the change (voted negatively, but not the minimum value)
    /// as an AccountInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disliked: Option<AccountInfo>,
    /// If true, the label blocks submit operation. If not set, the default is false.
    #[serde(default)]
    pub blocking: bool,
    /// List of all approvals for this label as a list of ApprovalInfo entities. Items in this list
    /// may not represent actual votes cast by users; if a user votes on any label, a corresponding
    /// ApprovalInfo will appear in this list for all labels.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<ApprovalInfo>>,
    /// The voting value of the user who recommended/disliked this label on the change
    /// if it is not “+1”/“-1”.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<i32>,
    /// The default voting value for the label. This value may be outside the range specified
    /// in permitted_labels.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_value: Option<i32>,
    /// A map of all values that are allowed for this label.
    /// The map maps the values (“-2”, “-1”, " `0`", “+1”, “+2”) to the value descriptions.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub values: Option<HashMap<String, String>>,
}

/// The MergeableInfo entity contains information about the mergeability of a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct MergeableInfo {
    /// Submit type used for this change.
    pub submit_type: SubmitType,
    /// The strategy of the merge.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub strategy: Option<MergeStrategy>,
    /// true if this change is cleanly mergeable, false otherwise
    pub mergeable: bool,
    /// true if this change is already merged, false otherwise
    #[serde(skip_serializing_if = "Option::is_none")]
    pub commit_merged: Option<bool>,
    /// true if the content of this change is already merged, false otherwise
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_merged: Option<bool>,
    /// A list of paths with conflicts.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conflicts: Option<Vec<String>>,
    /// A list of other branch names where this change could merge cleanly.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mergeable_into: Option<Vec<String>>,
}

/// The MergeInput entity contains information about the merge.
#[derive(Debug, Serialize, Deserialize)]
pub struct MergeInput {
    /// The source to merge from, e.g. a complete or abbreviated commit SHA-1,a complete reference
    /// name, a short reference name under refs/heads, refs/tags, or refs/remotes namespace, etc.
    pub source: String,
    /// A branch from which source is reachable. If specified, source is checked for visibility and
    /// reachability against only this branch. This speeds up the operation, especially for large
    /// repos with many branches.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_branch: Option<String>,
    /// The strategy of the merge.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub strategy: Option<MergeStrategy>,
    /// If true, creating the merge succeeds also if there are conflicts.
    /// If there are conflicts the file contents of the created change contain git conflict markers to indicate the conflicts.
    /// Callers can find out whether there were conflicts by checking the contains_git_conflicts field in the ChangeInfo.
    /// If there are conflicts the change is marked as work-in-progress.
    /// This option is not supported for all merge strategies (e.g. it’s supported for recursive and resolve, but not for simple-two-way-in-core).
    /// Defaults to false.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow_conflicts: Option<bool>,
}

/// The MergePatchSetInput entity contains information about updating a new change by creating
/// a new merge commit.
#[derive(Debug, Serialize, Deserialize)]
pub struct MergePatchSetInput {
    /// The new subject for the change, if not specified, will reuse the current patch set’s subject
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,
    /// Use the current patch set’s first parent as the merge tip when set to true.
    /// Default to false.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inherit_parent: Option<bool>,
    /// A {change-id} that identifies a change. When inherit_parent is false, the merge tip will be
    /// the current patch set of the base_change if it’s set. Otherwise, the current branch tip of
    /// the destination branch will be used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_change: Option<String>,
    /// The detail of the source commit for merge as a MergeInput entity.
    pub merge: MergeInput,
}

/// The strategy of the merge.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum MergeStrategy {
    Recursive,
    Resolve,
    SimpleTwoWayInCore,
    Ours,
    Theirs,
}

/// The MoveInput entity contains information for moving a change to a new branch.
#[derive(Debug, Serialize, Deserialize)]
pub struct MoveInput {
    /// Destination branch.
    pub destination_branch: String,
    /// A message to be posted in this change’s comments
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

/// Notify handling that defines to whom email notifications should be sent.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum NotifyHandling {
    All,
    None,
    Owner,
    OwnerReviewers,
}

/// The NotifyInfo entity contains detailed information about who should be notified about an
/// update. These notifications are sent out even if a notify option in the request input disables
/// normal notifications. NotifyInfo entities are normally contained in a notify_details map in the
/// request input where the key is the recipient type.
#[derive(Debug, Serialize, Deserialize)]
pub struct NotifyInfo {
    /// A list of account IDs that identify the accounts that should be should be notified.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub accounts: Option<Vec<String>>,
}

/// The PrivateInput entity contains information for changing the private flag on a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct PrivateInput {
    /// Message describing why the private flag was changed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

/// The ProblemInfo entity contains a description of a potential consistency problem with a change.
/// These are not related to the code review process, but rather indicate some inconsistency in
/// Gerrit’s database or repository metadata related to the enclosing change.
#[derive(Debug, Serialize, Deserialize)]
pub struct ProblemInfo {
    /// Plaintext message describing the problem with the change.
    pub message: String,
    /// The status of the problem.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ProblemStatus>,
    /// If status is set, an additional plaintext message describing the outcome of the fix.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outcome: Option<String>,
}

/// The status of the problem.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ProblemStatus {
    Fixed,
    FixFailed,
}

/// The PublishChangeEditInput entity contains options for the publishing of change edit.
#[derive(Debug, Serialize, Deserialize)]
pub struct PublishChangeEditInput {
    /// Notify handling that defines to whom email notifications should be sent
    /// after the change edit is published.
    /// If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
}

/// The PureRevertInfo entity describes the result of a pure revert check.
#[derive(Debug, Serialize, Deserialize)]
pub struct PureRevertInfo {
    /// Outcome of the check as boolean.
    pub is_pure_revert: bool,
}

/// The PushCertificateInfo entity contains information about a push certificate provided when
/// the user pushed for review with git push --signed HEAD:refs/for/<branch>.
/// Only used when signed push is enabled on the server.
#[derive(Debug, Serialize, Deserialize)]
pub struct PushCertificateInfo {
    /// Signed certificate payload and GPG signature block.
    pub certificate: String,
    /// Information about the key that signed the push, along with any problems found while checking
    /// the signature or the key itself, as a GpgKeyInfo entity.
    pub key: GpgKeyInfo,
}

/// The RangeInfo entity stores the coordinates of a range.
#[derive(Debug, Serialize, Deserialize)]
pub struct RangeInfo {
    /// First index.
    pub start: u32,
    /// Last index.
    pub end: u32,
}

/// The RebaseInput entity contains information for changing parent when rebasing.
#[derive(Debug, Serialize, Deserialize)]
pub struct RebaseInput {
    /// The new parent revision. This can be a ref or a SHA1 to a concrete patchset.
    /// Alternatively, a change number can be specified, in which case the current patch set is inferred.
    /// Empty string is used for rebasing directly on top of the target branch, which effectively breaks
    /// dependency towards a parent change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base: Option<String>,
}

/// The recipient type for notification handling.
#[derive(Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum RecipientType {
    To,
    Cc,
    Bcc,
}

/// The RelatedChangeAndCommitInfo entity contains information about a related change and commit.
#[derive(Debug, Serialize, Deserialize)]
pub struct RelatedChangeAndCommitInfo {
    /// The project of the change or commit.
    pub project: String,
    /// The Change-Id of the change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub change_id: Option<String>,
    /// The commit as a CommitInfo entity.
    pub commit: CommitInfo,
    /// The change number.
    #[serde(rename = "_change_number", skip_serializing_if = "Option::is_none")]
    pub change_number: Option<u32>,
    /// The revision number.
    #[serde(rename = "_revision_number", skip_serializing_if = "Option::is_none")]
    pub revision_number: Option<u32>,
    /// The current revision number.
    #[serde(
        rename = "_current_revision_number",
        skip_serializing_if = "Option::is_none"
    )]
    pub current_revision_number: Option<u32>,
    /// The status of the change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ChangeStatus>,
}

/// The RelatedChangesInfo entity contains information about related changes.
#[derive(Debug, Serialize, Deserialize)]
pub struct RelatedChangesInfo {
    /// A list of RelatedChangeAndCommitInfo entities describing the related changes.
    /// Sorted by git commit order, newest to oldest. Empty if there are no related changes.
    pub changes: Vec<RelatedChangeAndCommitInfo>,
}

/// The Requirement entity contains information about a requirement relative to a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct Requirement {
    /// Status of the requirement.
    pub status: RequirementStatus,
    /// A human readable reason.
    #[serde(rename = "fallbackText")]
    pub fallback_text: String,
    /// Alphanumerical (plus hyphens or underscores) string to identify what the requirement is and
    /// why it was triggered. Can be seen as a class: requirements sharing the same type were
    /// created for a similar reason, and the data structure will follow one set of rules.
    #[serde(rename = "type")]
    pub req_type: String,
    /// Holds custom key-value strings, used in templates to render richer status messages.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
}

/// Status of the requirement.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum RequirementStatus {
    Ok,
    NotReady,
    RuleError,
}

/// The RestoreInput entity contains information for restoring a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct RestoreInput {
    /// Message to be added as review comment to the change when restoring the change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

/// The RevertInput entity contains information for reverting a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct RevertInput {
    /// Message to be added as review comment to the change when reverting the change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Notify handling that defines to whom email notifications should be sent
    /// for reverting the change.
    /// If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
    /// Name of the topic for the revert change.
    /// If not set, the default for Revert endpoint is the topic of the change being reverted,
    /// and the default for the RevertSubmission endpoint is revert-{submission_id}-{timestamp.now}.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// The RevertSubmissionInfo entity describes the revert changes.
#[derive(Debug, Serialize, Deserialize)]
pub struct RevertSubmissionInfo {
    /// A list of ChangeInfo that describes the revert changes.
    /// Each entity in that list is a revert change that was created in that revert submission.
    pub revert_changes: Vec<ChangeInfo>,
}

/// The ReviewInfo entity contains information about a review.
#[derive(Debug, Serialize, Deserialize)]
pub struct ReviewInfo {
    /// The labels of the review as a map that maps the label names to the voting values.
    pub labels: BTreeMap<String, i32>,
}

/// The Reviewer State
#[derive(Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ReviewerState {
    /// Users with at least one non-zero vote on the change.
    Reviewer,
    /// Users that were added to the change, but have not voted.
    Cc,
    /// Users that were previously reviewers on the change, but have been removed.
    Removed,
}

/// The ReviewerUpdateInfo entity contains information about updates to change’s reviewers set.
#[derive(Debug, Serialize, Deserialize)]
pub struct ReviewerUpdateInfo {
    /// Timestamp of the update.
    pub updated: Timestamp,
    /// The account which modified state of the reviewer in question as AccountInfo entity.
    pub updated_by: AccountInfo,
    /// The reviewer account added or removed from the change as an AccountInfo entity.
    pub reviewer: AccountInfo,
    /// The reviewer state.
    pub state: ReviewerState,
}

/// The ReviewInput entity contains information for adding a review to a revision.
#[derive(Debug, Serialize, Deserialize)]
pub struct ReviewInput {
    /// The message to be added as review comment.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Apply this tag to the review comment message, votes, and inline comments.
    /// Tags may be used by CI or other automated systems to distinguish them from human reviews.
    /// Votes/comments that contain tag with 'autogenerated:' prefix can be filtered out in the web UI.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
    /// The votes that should be added to the revision as a map that maps the label names to the voting values.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, i32>>,
    /// The comments that should be added as a map that maps a file path to a list of CommentInput entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comments: Option<HashMap<String, Vec<CommentInput>>>,
    /// The robot comments that should be added as a map that maps a file path to a list of RobotCommentInput entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub robot_comments: Option<HashMap<String, Vec<RobotCommentInput>>>,
    /// Draft handling that defines how draft comments are handled that are already in the database
    /// but that were not also described in this input.
    /// Allowed values are PUBLISH, PUBLISH_ALL_REVISIONS and KEEP.
    /// All values except PUBLISH_ALL_REVISIONS operate only on drafts for a single revision.
    /// Only KEEP is allowed when used in conjunction with on_behalf_of.
    /// If not set, the default is KEEP. If on_behalf_of is set, then no other value besides KEEP is allowed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub drafts: Option<DraftHandling>,
    /// Notify handling that defines to whom email notifications should be sent after the review is stored.
    /// If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
    /// If true, comments with the same content at the same place will be omitted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub omit_duplicate_comments: Option<bool>,
    /// {account-id} the review should be posted on behalf of.
    /// To use this option the caller must have been granted labelAs-NAME permission for all keys of labels.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub on_behalf_of: Option<String>,
    /// A list of ReviewerInput representing reviewers that should be added to the change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewers: Option<Vec<ReviewerInput>>,
    /// If true, and if the change is work in progress, then start review.
    /// It is an error for both ready and work_in_progress to be true.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ready: Option<bool>,
    /// If true, mark the change as work in progress.
    /// It is an error for both ready and work_in_progress to be true.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub work_in_progress: Option<bool>,
}

/// The ReviewerInfo entity contains information about a reviewer and its votes on a change.
/// ReviewerInfo has the same fields as AccountInfo and includes detailed account information.
/// In addition ReviewerInfo has the following fields:
#[derive(Debug, Serialize, Deserialize)]
pub struct ReviewerInfo {
    /// The account information entity.
    #[serde(flatten)]
    pub account: AccountInfo,
    /// The approvals of the reviewer as a map that maps the label names to
    /// the approval values (“-2”, “-1”, “0”, “+1”, “+2”).
    pub approvals: BTreeMap<String, i32>,
}

/// The ReviewerInput entity contains information for adding a reviewer to a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct ReviewerInput {
    /// The ID of one account that should be added as reviewer or the ID of one internal group for
    /// which all members should be added as reviewers.
    /// If an ID identifies both an account and a group, only the account is added as reviewer to the change.
    /// External groups, such as LDAP groups, will be silently omitted from a set-review or add-reviewer call.
    pub reviewer: String,
    /// Add reviewer in this state.
    /// If not given, defaults to REVIEWER.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<ReviewerState>,
    /// Whether adding the reviewer is confirmed.
    /// The Gerrit server may be configured to require a confirmation when adding a group as
    /// reviewer that has many members.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confirmed: Option<bool>,
    /// Notify handling that defines to whom email notifications should be sent after
    /// the reviewer is added.
    /// If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
}

/// The ReviewerInput entity contains information for adding a reviewer to a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct RevisionInfo {
    /// The change kind.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<ChangeKind>,
    /// The patch set number, or edit if the patch set is an edit.
    pub _number: u32,
    /// The timestamp of when the patch set was created.
    pub created: Timestamp,
    /// The uploader of the patch set as an AccountInfo entity.
    pub uploader: AccountInfo,
    /// The Git reference for the patch set.
    #[serde(rename = "ref")]
    pub refspec: String,
    /// Information about how to fetch this patch set.
    /// The fetch information is provided as a map that maps the protocol name (“git”, “http”, “ssh”)
    /// to FetchInfo entities. This information is only included if a plugin implementing the
    /// download commands interface is installed.
    pub fetch: HashMap<String, FetchInfo>,
    /// The commit of the patch set as CommitInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub commit: Option<CommitInfo>,
    /// The files of the patch set as a map that maps the file names to FileInfo entities.
    /// Only set if CURRENT_FILES or ALL_FILES option is requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, FileInfo>>,
    /// Actions the caller might be able to perform on this revision.
    /// The information is a map of view name to ActionInfo entities.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<BTreeMap<String, ActionInfo>>,
    /// Indicates whether the caller is authenticated and has commented on the current revision.
    /// Only set if REVIEWED option is requested.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed: Option<bool>,
    /// If the COMMIT_FOOTERS option is requested and this is the current patch set,
    /// contains the full commit message with Gerrit-specific commit footers, as if this revision
    /// were submitted using the Cherry Pick submit type.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub commit_with_footers: Option<String>,
    /// If the PUSH_CERTIFICATES option is requested, contains the push certificate provided by the
    /// user when uploading this patch set as a PushCertificateInfo entity.
    /// This field is always set if the option is requested;
    /// if no push certificate was provided, it is set to an empty object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub push_certificate: Option<PushCertificateInfo>,
    /// The description of this patchset, as displayed in the patchset selector menu.
    /// May be null if no description is set.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

/// The RobotCommentInfo entity contains information about a robot inline comment.
/// RobotCommentInfo has the same fields as CommentInfo. In addition RobotCommentInfo has the following fields:
#[derive(Debug, Serialize, Deserialize)]
pub struct RobotCommentInfo {
    /// The comment information entity.
    #[serde(flatten)]
    pub comment: CommentInfo,
    /// The ID of the robot that generated this comment.
    pub robot_id: String,
    /// An ID of the run of the robot.
    pub robot_run_id: String,
    /// URL to more information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// Robot specific properties as map that maps arbitrary keys to values.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<HashMap<String, String>>,
    /// Suggested fixes for this robot comment as a list of FixSuggestionInfo entities.
    pub fix_suggestions: Vec<FixSuggestionInfo>,
}

/// The RobotCommentInput entity contains information for creating an inline robot comment.
/// RobotCommentInput has the same fields as RobotCommentInfo.
#[derive(Debug, Serialize, Deserialize)]
pub struct RobotCommentInput {
    /// The robot comment information entity.
    #[serde(flatten)]
    pub inner: RobotCommentInfo,
}

/// The RuleInput entity contains information to test a Prolog rule.
#[derive(Debug, Serialize, Deserialize)]
pub struct RuleInput {
    /// Prolog code to execute instead of the code in refs/meta/config.
    pub rule: String,
    /// When RUN filter rules in the parent projects are called to post-process the results of the
    /// project specific rule. This behavior matches how the rule will execute if installed.
    /// If SKIP the parent filters are not called, allowing the test to return results from the input rule.
    /// RUN if not set.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filters: Option<RuleFilter>,
}

/// Rule filter.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum RuleFilter {
    Run,
    Skip,
}

/// The SubmitInfo entity contains information about the change status after submitting.
#[derive(Debug, Serialize, Deserialize)]
pub struct SubmitInfo {
    /// The status of the change after submitting is MERGED.
    pub status: ChangeStatus,
    /// The {account-id} of the user on whose behalf the action should be done.
    /// To use this option the caller must have been granted both Submit and Submit (On Behalf Of) permissions.
    /// The user named by on_behalf_of does not need to be granted the Submit permission.
    /// This feature is aimed for CI solutions: the CI account can be granted both permissions,
    /// so individual users don’t need Submit permission themselves.
    /// Still the changes can be submitted on behalf of real users and not with the identity of the CI account.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub on_behalf_of: Option<String>,
}

/// The SubmitInput entity contains information for submitting a change.
#[derive(Debug, Serialize, Deserialize)]
pub struct SubmitInput {
    /// If set, submit the change on behalf of the given user.
    /// The value may take any format accepted by the accounts REST API.
    /// Using this option requires Submit (On Behalf Of) permission on the branch.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub on_behalf_of: Option<String>,
    /// Notify handling that defines to whom email notifications should be sent after
    /// the change is submitted.
    /// If not set, the default is ALL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify: Option<NotifyHandling>,
    /// Additional information about whom to notify about the update as a
    /// map of recipient type to NotifyInfo entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_details: Option<HashMap<RecipientType, NotifyInfo>>,
}

/// The SubmitRecord entity describes results from a submit_rule.
/// Fields in this entity roughly correspond to the fields set by LABELS in LabelInfo.
#[derive(Debug, Serialize, Deserialize)]
pub struct SubmitRecord {
    /// The submit status.
    pub status: SubmitStatus,
    /// Map of labels that are approved; an AccountInfo identifies the voter chosen by the rule.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ok: Option<BTreeMap<String, AccountInfo>>,
    /// Map of labels that are preventing submit; AccountInfo identifies voter.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reject: Option<BTreeMap<String, AccountInfo>>,
    /// Map of labels that can be used, but do not affect submit.
    /// AccountInfo identifies voter, if the label has been applied.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub need: Option<BTreeMap<String, AccountInfo>>,
    /// Map of labels that should have been in need but cannot be used by any user because of access restrictions.
    /// The value is currently an empty object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impossible: Option<BTreeMap<String, ()>>,
    /// When status is RULE_ERROR this message provides some text describing the failure of the rule predicate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
}

/// Submit type.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum SubmitType {
    Inherit,
    FastForwardOnly,
    MergeIfNecessary,
    MergeAlways,
    CherryPick,
    RebaseIfNecessary,
    RebaseAlways,
}

impl std::fmt::Display for SubmitType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.write_str(match self {
            SubmitType::Inherit => "Inherit",
            SubmitType::FastForwardOnly => "Fast-Forward only",
            SubmitType::MergeIfNecessary => "Merge if Necessary",
            SubmitType::MergeAlways => "Merge Always ",
            SubmitType::CherryPick => "Cherry-Pick",
            SubmitType::RebaseIfNecessary => "Rebase if Necessary",
            SubmitType::RebaseAlways => "Rebase Always",
        })
    }
}

/// The SubmittedTogetherInfo entity contains information about a collection of changes that would be submitted together.
#[derive(Debug, Serialize, Deserialize)]
pub struct SubmittedTogetherInfo {
    /// A list of ChangeInfo entities representing the changes to be submitted together.
    pub changes: Vec<ChangeInfo>,
    /// The number of changes to be submitted together that the current user cannot see.
    /// (This count includes changes that are visible to the current user when their reason for
    /// being submitted together involves changes the user cannot see.)
    pub non_visible_changes: u32,
}

/// Submit status.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum SubmitStatus {
    /// The change can be submitted.
    Ok,
    /// Additional labels are required before submit.
    NotReady,
    /// Closed changes cannot be submitted.
    Closed,
    /// Rule code failed with an error.
    RuleError,
}

/// The SuggestedReviewerInfo entity contains information about a reviewer that can be added to a
/// change (an account or a group).
/// SuggestedReviewerInfo has either the account field that contains the AccountInfo entity,
/// or the group field that contains the GroupBaseInfo entity.
#[derive(Debug, Serialize, Deserialize)]
pub struct SuggestedReviewerInfo {
    /// An AccountInfo entity, if the suggestion is an account.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account: Option<AccountInfo>,
    /// A GroupBaseInfo entity, if the suggestion is a group.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group: Option<GroupBaseInfo>,
    /// The total number of accounts in the suggestion.
    /// This is 1 if account is present. If group is present, the total number of accounts that are
    /// members of the group is returned (this count includes members of nested groups).
    pub count: u32,
    /// True if group is present and count is above the threshold where the confirmed flag must be
    /// passed to add the group as a reviewer.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confirm: Option<bool>,
}

/// The TopicInput entity contains information for setting a topic.
#[derive(Debug, Serialize, Deserialize)]
pub struct TopicInput {
    /// The topic.
    pub topic: String,
}

/// The TrackingIdInfo entity describes a reference to an external tracking system.
#[derive(Debug, Serialize, Deserialize)]
pub struct TrackingIdInfo {
    /// The name of the external tracking system.
    pub system: String,
    /// The tracking id.
    pub id: String,
}

/// The VotingRangeInfo entity describes the continuous voting range from min to max values.
#[derive(Debug, Serialize, Deserialize)]
pub struct VotingRangeInfo {
    /// The minimum voting value.
    pub min: i32,
    /// The maximum voting value.
    pub max: i32,
}

/// The WebLinkInfo entity describes a link to an external site.
#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct WebLinkInfo {
    /// The link name.
    pub name: String,
    /// The link URL.
    pub url: String,
    /// URL to the icon of the link.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_url: Option<String>,
}

/// The WorkInProgressInput entity contains additional information for a change set to WorkInProgress/ReadyForReview.
#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct WorkInProgressInput {
    /// Message to be added as a review comment to the change being set WorkInProgress/ReadyForReview.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// REST API
////////////////////////////////////////////////////////////////////////////////////////////////////

/// Query parameters available for the change endpoint.
#[derive(Debug, Default, Serialize)]
pub struct QueryParams {
    /// Queries strings for searching changes.
    #[serde(rename = "q", skip_serializing_if = "Option::is_none")]
    pub search_queries: Option<Vec<QueryStr>>,
    /// Additional Options to extend the query results
    #[serde(rename = "o", skip_serializing_if = "Option::is_none")]
    pub additional_opts: Option<Vec<AdditionalOpt>>,
    /// Limit the returned results to no more than X records.
    #[serde(rename = "n", skip_serializing_if = "Option::is_none")]
    pub limit: Option<u32>,
    /// The start query parameter can be supplied to skip a number of changes from the list.
    #[serde(rename = "S", skip_serializing_if = "Option::is_none")]
    pub start: Option<u32>,
}

/// Additional fields can be obtained by adding `o` parameters, each option requires more database
/// lookups and slows down the query response time to the client so they are generally disabled by default.
#[derive(AsRefStr, Display, Debug, Serialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[strum(serialize_all = "shouty_snake_case")]
pub enum AdditionalOpt {
    /// A summary of each label required for submit, and approvers that have granted (or rejected)
    /// with that label.
    Labels,
    /// Detailed label information, including numeric values of all existing approvals,
    /// recognized label values, values permitted to be set by the current user, all reviewers by state,
    /// and reviewers that may be removed by the current user.
    DetailedLabels,
    /// Describe the current revision (patch set) of the change, including the commit SHA-1 and URLs to fetch from.
    CurrentRevision,
    /// Describe all revisions, not just current.
    AllRevisions,
    /// Include the commands field in the FetchInfo for revisions.
    /// Only valid when the CURRENT_REVISION or ALL_REVISIONS option is selected.
    DownloadCommands,
    /// Parse and output all header fields from the commit object, including message.
    /// Only valid when the CURRENT_REVISION or ALL_REVISIONS option is selected.
    CurrentCommit,
    /// parse and output all header fields from the output revisions.
    /// If only CURRENT_REVISION was requested then only the current revision’s commit data will be output.
    AllCommits,
    /// list files modified by the commit and magic files, including basic line counts inserted/deleted per file.
    /// Only valid when the CURRENT_REVISION or ALL_REVISIONS option is selected.
    CurrentFiles,
    /// List files modified by the commit and magic files, including basic line counts inserted/deleted
    /// per file. If only the CURRENT_REVISION was requested then only that commit’s modified files will be output.
    AllFiles,
    /// Include _account_id, email and username fields when referencing accounts.
    DetailedAccounts,
    /// Include updates to reviewers set as ReviewerUpdateInfo entities.
    ReviewerUpdates,
    /// Include messages associated with the change.
    Messages,
    /// Include information on available actions for the change and its current revision.
    /// Ignored if the caller is not authenticated.
    CurrentActions,
    /// Include information on available change actions for the change.
    /// Ignored if the caller is not authenticated.
    ChangeActions,
    /// Include the reviewed field if all of the following are true:
    ///  - the change is open
    ///  - the caller is authenticated
    ///  - the caller has commented on the change more recently than the last update from the change owner,
    ///    i.e. this change would show up in the results of reviewedby:self.
    Reviewed,
    /// Skip the 'insertions' and 'deletions' field in ChangeInfo.
    /// For large trees, their computation may be expensive.
    SkipDiffstat,
    /// Include the submittable field in ChangeInfo,
    /// which can be used to tell if the change is reviewed and ready for submit.
    Submittable,
    /// Include the web_links field in CommitInfo, therefore only valid in combination with CURRENT_COMMIT or ALL_COMMITS.
    WebLinks,
    /// Include potential problems with the change.
    Check,
    /// Include the full commit message with Gerrit-specific commit footers in the RevisionInfo.
    CommitFooters,
    /// Include push certificate information in the RevisionInfo. Ignored if signed push is not enabled on the server.
    PushCertificates,
    /// Include references to external tracking systems as TrackingIdInfo.
    TrackingIds,
}

#[derive(Debug)]
pub enum QueryStr {
    Raw(String),
    Cooked(Vec<QueryOpr>),
}

#[derive(Debug)]
pub enum QueryOpr {
    Search(SearchOpr),
    Bool(BoolOpr),
    Group(GroupOpr),
}

#[derive(Debug)]
pub enum SearchOpr {
    Is(Is),
    Owner(String),
    Reviewer(String),
    Limit(u32),
}

#[derive(AsRefStr, Display, Debug)]
#[strum(serialize_all = "shouty_snake_case")]
pub enum BoolOpr {
    Not,
    And,
    Or,
}

#[derive(AsRefStr, Display, Debug)]
pub enum GroupOpr {
    #[strum(serialize = "(")]
    Begin,
    #[strum(serialize = ")")]
    End,
}

#[derive(AsRefStr, Display, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
#[strum(serialize_all = "snake_case")]
pub enum Is {
    Assigned,
    Unassigned,
    Starred,
    Watched,
    Reviewed,
    Owner,
    Reviewer,
    Cc,
    Ignored,
    New,
    Open,
    Pending,
    Draft,
    Closed,
    Merged,
    Abandoned,
    Submittable,
    Mergeable,
    Private,
    Wip,
}

impl Serialize for QueryStr {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            QueryStr::Raw(s) => serializer.serialize_str(s.as_str()),
            QueryStr::Cooked(operators) => {
                let mut strings: Vec<String> = Vec::new();
                strings.reserve(operators.len());
                for opr in operators {
                    strings.push(format!("{}", opr));
                }
                println!("{:#?}", strings);
                let joined = strings.join(" ");
                serializer.serialize_str(joined.as_str())
            }
        }
    }
}

impl Display for QueryOpr {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {
        match self {
            QueryOpr::Search(s) => write!(f, "{}", s),
            QueryOpr::Bool(b) => write!(f, "{}", b.as_ref()),
            QueryOpr::Group(g) => write!(f, "{}", g.as_ref()),
        }
    }
}

impl Display for SearchOpr {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {
        match self {
            SearchOpr::Is(o) => write!(f, "is:{}", o),
            SearchOpr::Owner(o) => write!(f, "owner:{}", o),
            SearchOpr::Reviewer(o) => write!(f, "reviewer:{}", o),
            SearchOpr::Limit(o) => write!(f, "limit:{}", o),
        }
    }
}
